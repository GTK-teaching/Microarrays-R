---
title: "Identifying differentially expressed genes using linear models"
source: Rmd
teaching: 20
exercises: 20
questions:
  - "How do we identify genes that are differentially expressed in a statistically rigorous manner?"
objectives:
  - "Be able to use `limma` to identify differentially expressed genes."
  - "Understand the formula class of objects in R, and use it to specify the appropriate model for linear modeling." 
keypoints:
  - "The `formula` class of objects in R enables us to represent a wide range of models to identify differentially expressed genes."
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
source("../bin/chunk-options.R")
library(affy)
load('.RData')
library(GEOquery)
```

## The formula class of objects 

The **formula** class is the work horse of statistical modeling in R. We use `~` in the
specification of the model, where `y ~ x` means the response `y` is modelled by a linear variable
`x`. More complex models are possible using the operators `+`, `*`, `:`, and others. Refer to [the
formula manual][formula] for more information on the different operators and their meaning in a
formula. Linear models expressed this way include an implicit 'intercept' term, which we can remove
from the model by indicating `+ 0` in our model formula. For a variety of reasons, it's often
convenient to remove the intercept term when doing differential gene expression analysis.

## Identifying differentially expressed features

In a transcriptomics experiment, whether using microarrays or RNA-seq, we often fit the data from
*every* transcript as a response against a common model of independent variables. The variables
describe the experiment, and we specify just the right side of a formula (the left side being used
to fit the data). For example, if we have a treatment `x` that can take several values,
and the actual value of `x` varies across samples, we might specify a model by

```{r, eval=FALSE}
~ x
```

or possibly

```{r, eval=FALSE}
~ 0 + x
```
The second formula explicitly removes the intercept.

Fitting such a model, however, doesn't tell us if there is differential expression between
treatments `X`. For that we have to specify *contrasts*, which are the comparisons we wish to make.
if `X` represents two alternative treatments, we simply want to know if the gene expresison is
different for one treatment versus the other.

## Specifying our model for differential gene expression analysis

In order to identify differentially expressed genes using linear models, we need to do two
things:

1. Generate a model matrix specifying the design, and ;
2. Generate a contrast matrix, specifying the comparisons of interest. 

The former is fits the model to the data, while the second performs statistical testing to
identify which genes are differentially expressed.

Since `culture` just takes on two values, we can just look at one contrast, which is when they differ.

The first key function is `model.matrix`. This function builds a matrix that describes the design of our experiment.

```{r}
library(limma)
model <- model.matrix( ~ 0 + eset$culture)
## rename the model columns to correspond to the different growth conditions.
colnames(model) <- levels(eset$culture)
```
As you can see, this function has created a matrix with two binary columns. These represent the two possible values of the culture conditions.


```{r,echo=FALSE}
kable(model)
```

Since we only want to look at when the growth conditions *differ*, we create that one contrast with `makeContrasts()`

```{r}
contrasts <- makeContrasts(SCGM - MEGM, levels=model)
contrasts
```

In our contrast matrix, we are interested in finding out the
difference between the group grown in SCGM (the EMT phenotype) and
the control (grown in MEGM). For that reason, we used `SCGM-MEGM`, with the latter being the reference. 
This formulation means that when the log fold change is *positive*, expression is greater in SCGM than MEGM, and vice versa.
Naturally, you can perform more complex analysis with multiple comparisons depending on
the question of interest. You can read up more on using *limma* for more complex analysis
from the *limma* user guide (available at
https://bioconductor.org/packages/release/bioc/vignettes/limma/inst/doc/usersguide.pdf,
and in particular, pages 35-64), which demonstrates the use of *limma* for a wide range of
questions and even two-colored platforms.

> ## The importance of a good model
>
> While the process of fitting a model to the data is not difficult, the difficulty that
> is most often encountered is the choice of an appropriate model. Many times, there are
> underlying confounders that are not immediately apparent but have significant impact on
> the results. One such confounder frequently encountered in microarrays is *batch effect*,
> which arises when samples are analyzed on different days by different people, leading to
> the introduction of technical artifacts. For this reason, exploratory data analysis (EDA)
> is critical to understanding the nature of data prior to model fitting. While outside the
> scope of this practical, it is a worthwhile investment to find out some of these methods
> and also how one can correct for these technical differences in a statistically robust
> manner.
{: .idea}
 
## Model fitting

Once we have generated both model and contrast matrix, we will then proceed to fit them to the data. This is accomplished in just two lines of code in R: 


```{r}
fit <- lmFit(eset, model)
fitted.contrast <- contrasts.fit(fit,contrasts)
```


## Empirical Bayes correction in `limma` 

Empirical Bayes (eBayes) is a method that borrows information about the distribution
across genes to calculate a robust test statistic. In `limma`, this can be performed using
the `eBayes()` function. The function requires that we provide an object returned from
fitting a linear model (or contrast matrix) to the data. Once we have fitted the contrast
matrix to the data, performing eBayes correction is easily done in R using the following
line of code:

```{r}
fitted.ebayes <- eBayes(fitted.contrast)
```

## Extracting differentially expressed genes 

We now have, model fits for each feature on the array, and we can arrange them in a table using
`TopTable()` By default, TopTable will provide the top 10 features sorted by the "B" statistic,
which is the log odds of differential expression.

```{r,eval=FALSE}
topTable(fitted.ebayes)
```

```{r,echo=FALSE}
kable(tibble::as_tibble(as.data.frame(topTable(fitted.ebayes)),rownames='probeset'))
```



> ## Think about it
>
> By default, `topTable()` returns only the top ten genes ranked by their B value. How do
> you get the statistics associated with all the genes on the array? Explore the options of
> topTable to identify lists of genes that fit your criteria of interest.
{: .callout}

{% include links.md %}

[formula]: https://stat.ethz.ch/R-manual/R-devel/library/stats/html/formula.html
