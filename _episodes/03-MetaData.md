---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 03-MetaData.md in _episodes_rmd/
title: Creating and attaching a phenoData object
teaching: 10
exercises: 10
source: Rmd
objectives:
- Be able to use metadata from GEO objects to construct useful R data objects
- Be able to use read.affybatch in combination with your own phenoData object to ensure data integrity
questions:
- "If an experiment were more complicated, and included several independent variables, would you be able to create a phenoData object from the GSE?"
keypoints: 
- GEO metadata can be cast into R data objects for analysis. The details are up to the user.
- Using a proper phenoData object to describe an experiment helps to ensure reproducibility and avoid reading in files out of order
---



We have successfully read in CEL files into an AffyBatch object, but we got a warning because we didn't have any information about the experiment in a phenoData object. A phenoData object is just a description of the experiment itself. In this case, the experiment is pretty simple: the treatment conditions.  Let's see if we can find the information we need from the metadata.


~~~
names(Meta(gse))
~~~
{: .language-r}



~~~
 [1] "contact_address"         "contact_city"           
 [3] "contact_country"         "contact_department"     
 [5] "contact_institute"       "contact_laboratory"     
 [7] "contact_name"            "contact_state"          
 [9] "contact_zip/postal_code" "contributor"            
[11] "email"                   "geo_accession"          
[13] "institute"               "last_update_date"       
[15] "name"                    "overall_design"         
[17] "platform_id"             "platform_taxid"         
[19] "relation"                "sample_id"              
[21] "sample_taxid"            "status"                 
[23] "submission_date"         "summary"                
[25] "supplementary_file"      "title"                  
[27] "type"                    "web_link"               
~~~
{: .output}

These are all the information we have in the metadata of the series. But the sample information is in the GSM, not the GSE, so let's look there. You should have a GSM object names gsm from our earlier download. If you don't have one now you can create one now with `gsm <- GSMList(gse)[[1]]`. (Remember, a GSE includes a list of GSMs.)


~~~
names(Meta(gsm))
~~~
{: .language-r}



~~~
 [1] "channel_count"           "characteristics_ch1"    
 [3] "contact_address"         "contact_city"           
 [5] "contact_country"         "contact_department"     
 [7] "contact_institute"       "contact_laboratory"     
 [9] "contact_name"            "contact_state"          
[11] "contact_zip/postal_code" "data_processing"        
[13] "data_row_count"          "description"            
[15] "extract_protocol_ch1"    "geo_accession"          
[17] "growth_protocol_ch1"     "hyb_protocol"           
[19] "label_ch1"               "label_protocol_ch1"     
[21] "last_update_date"        "molecule_ch1"           
[23] "organism_ch1"            "platform_id"            
[25] "scan_protocol"           "series_id"              
[27] "source_name_ch1"         "status"                 
[29] "submission_date"         "supplementary_file"     
[31] "taxid_ch1"               "title"                  
[33] "treatment_protocol_ch1"  "type"                   
~~~
{: .output}

Compare the metadata for the GSE and the GSM. See how much of it is repeated?  We can find out which ones are different using a combination of `!` and `%in%`:

> ## Try it!
>
> See if you can extract the subset of metadata that is *present* in the GSM but *not present in the GSE. These are the metadata that describe each sample, rather than the whole series.
>
> > ## Solution
> >
> > The `names()` function gives us the character vectors we want to compare. We can use `%in%` to
> > give us a logical vector of which GSM metadata is also in GSE metadata. We then use `!` to invert
> > the logic. The result is the metadata of GSM that is *not* in the GSE.
> > We can then extract the values for those names.
> >
> > 
> > ~~~
> > names(Meta(gsm))[!(names(Meta(gsm)) %in% names(Meta(gse)))]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> >  [1] "channel_count"          "characteristics_ch1"    "data_processing"       
> >  [4] "data_row_count"         "description"            "extract_protocol_ch1"  
> >  [7] "growth_protocol_ch1"    "hyb_protocol"           "label_ch1"             
> > [10] "label_protocol_ch1"     "molecule_ch1"           "organism_ch1"          
> > [13] "scan_protocol"          "series_id"              "source_name_ch1"       
> > [16] "taxid_ch1"              "treatment_protocol_ch1"
> > ~~~
> > {: .output}
> > 
> > 
> > 
> > ~~~
> > Meta(gsm)[!(names(Meta(gsm)) %in% names(Meta(gse)))]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > $channel_count
> > [1] "1"
> > 
> > $characteristics_ch1
> > [1] "cell line: Human breast cancer-derived cell line DKAT"
> > [2] "culture medium: SCGM"                                 
> > 
> > $data_processing
> > [1] "The data were analyzed with RMA using the affy package implemented in BRB array tools (Simon and Lam, ver. 3.7.0; R ver. 2.6.0)"
> > 
> > $data_row_count
> > [1] "54675"
> > 
> > $description
> > [1] "DKAT cells cultured in SCGM (Lonza) for 14 days"
> > [2] "HGU133(+2.0)_23_E3.CEL"                         
> > 
> > $extract_protocol_ch1
> > [1] "Extraction of total RNA was performed using the Qiagen RNeasy kit according to the manufacturer's instructions with option DNAse step."
> > 
> > $growth_protocol_ch1
> > [1] "DKAT cells (passage 10) in MEGM were split and grown for 14 days either in MEGM (Lonza) or SCGM (Lonza) in adherent culture."
> > 
> > $hyb_protocol
> > [1] "Following fragmentation, 10 ug of cRNA were hybridized in an Affymetrix Hybridization Oven 640 for 16 hr at 45°C on HG-U133 Plus2.0 GeneChips. GeneChips were washed and stained on an Affymetrix Fluidics Station 450, using the manufacture’s recommended protocol."
> > 
> > $label_ch1
> > [1] "biotin"
> > 
> > $label_protocol_ch1
> > [1] "Biotinylated cRNA were prepared according to the standard Affymetrix protocol from 4ug total RNA (Expression Analysis Technical Manual, 2001, Affymetrix)."
> > 
> > $molecule_ch1
> > [1] "total RNA"
> > 
> > $organism_ch1
> > [1] "Homo sapiens"
> > 
> > $scan_protocol
> > [1] "GeneChips were scanned using an Affymetrix GeneChip Scanner."
> > 
> > $series_id
> > [1] "GSE33146" "GSE33167"
> > 
> > $source_name_ch1
> > [1] "DKAT cells cultured in SCGM (Lonza) for 14 days"
> > 
> > $taxid_ch1
> > [1] "9606"
> > 
> > $treatment_protocol_ch1
> > [1] "DKAT cells (passage 10) in MEGM were split and grown for 14 days either in MEGM (Lonza) or SCGM (Lonza) in adherent culture."
> > ~~~
> > {: .output}
> > Now we can see that a few metadata elements tell us the key information: 
> > which samples are grown in which media. It looks like we can use 
> > `source_name_ch1`, `growth_protocol_ch1`, or `characteristics_ch1`.
> {: .solution}
{: .challenge}

## Getting the sample growth conditions into a data frame


~~~
for (gsm in GSMList(gse)) { 
  print(Meta(gsm)[['characteristics_ch1']])
  }
~~~
{: .language-r}



~~~
[1] "cell line: Human breast cancer-derived cell line DKAT"
[2] "culture medium: MEGM"                                 
[1] "cell line: Human breast cancer-derived cell line DKAT"
[2] "culture medium: MEGM"                                 
[1] "cell line: Human breast cancer-derived cell line DKAT"
[2] "culture medium: MEGM"                                 
[1] "cell line: Human breast cancer-derived cell line DKAT"
[2] "culture medium: SCGM"                                 
[1] "cell line: Human breast cancer-derived cell line DKAT"
[2] "culture medium: SCGM"                                 
[1] "cell line: Human breast cancer-derived cell line DKAT"
[2] "culture medium: SCGM"                                 
~~~
{: .output}

OK, that looks right, but *printing* the results are a side effect; it doesn't get us any data. Remember how R `apply` loops work?


~~~
culture_medium <- function(gsm) { 
  Meta(gsm)[['characteristics_ch1']][2]
}
sapply(GSMList(gse),culture_medium)
~~~
{: .language-r}



~~~
             GSM820817              GSM820818              GSM820819 
"culture medium: MEGM" "culture medium: MEGM" "culture medium: MEGM" 
             GSM820820              GSM820821              GSM820822 
"culture medium: SCGM" "culture medium: SCGM" "culture medium: SCGM" 
~~~
{: .output}

This works a lot like a `for` loop, but returns data from a function. 

Let's put it into a data frame.


~~~
pd <- data.frame(culture=as.factor(sapply(GSMList(gse),culture_medium)))
pd
~~~
{: .language-r}


|          |culture              |
|:---------|:--------------------|
|GSM820817 |culture medium: MEGM |
|GSM820818 |culture medium: MEGM |
|GSM820819 |culture medium: MEGM |
|GSM820820 |culture medium: SCGM |
|GSM820821 |culture medium: SCGM |
|GSM820822 |culture medium: SCGM |

The `culture` column only has two values; let's make it a bit simpler.


~~~
pd$culture <- as.factor(pd$culture)
levels(pd$culture) <- c("MEGM","SCGM")
kable(pd)
~~~
{: .language-r}



|          |culture |
|:---------|:-------|
|GSM820817 |MEGM    |
|GSM820818 |MEGM    |
|GSM820819 |MEGM    |
|GSM820820 |SCGM    |
|GSM820821 |SCGM    |
|GSM820822 |SCGM    |


## Reading in the CEL files with the phenoData

Remember the risk of using `read.affybatch()`? Now that we have the data frame, let's re-run it, but use the data frame to provide the pData. This *guarantees* that the samples and the meta-data will be properly aligned.


> ## Solution
>
> 
> ~~~
> celfiles <- paste0('data/',rownames(pd),'.CEL.gz')
> affydata <- read.affybatch(celfiles,phenoData = new("AnnotatedDataFrame",pd))
> phenoData(affydata)
> ~~~
> {: .language-r}
> 
> 
> 
> ~~~
> An object of class 'AnnotatedDataFrame'
>   sampleNames: GSM820817 GSM820818 ... GSM820822 (6 total)
>   varLabels: culture
>   varMetadata: labelDescription
> ~~~
> {: .output}
> That works, and no errors! We are good to go.
>
{: .solution}




{% include site-links.md %} 
{% include links.md %} 
