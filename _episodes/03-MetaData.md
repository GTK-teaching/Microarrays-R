---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 03-MetaData.md in _episodes_rmd/
title: Working with experimental metadata
teaching: 10
exercises: 10
source: Rmd
objectives:
- Be able to use metadata from GEO objects to construct useful R data objects
- Be able to use read.affybatch in combination with your own phenoData object to ensure data integrity
questions:
- "If an experiment were more complicated, and included several independent variables, would you be able to create a phenoData object from the GSE?"
keypoints: 
- GEO metadata can be cast into R data objects for analysis. The details are up to the user.
- Using a proper phenoData object to describe an experiment helps to ensure reproducibility and avoid reading in files out of order
---



We have successfully read in CEL files into an R object, but we haven't provided any data about the experiment design, which would normally be provided in a phenoData object. A phenoData object is just a description of the experiment itself. In this case, the experiment is pretty simple: the two treatment conditions.  Let's see if we can find the information we need from the metadata.

> ## We have two starting points.
>
> 1. If you have been following this tutorial, you probably have two starting points. One is an object called `gse` which is a list of ExpressionSet objects. That list has length 1, so the first element of the list, `gse[[1]]`, is an ExpressionSet object. 
>
> 2. You may also have another object, called `gse2`, from `gse2<-
> getGEO('GSE33146',GSEMatrix=FALSE))`, that does not have an
> ExpressionSet object. The result of that operation is a `GSE`
> object; it contains a list of samples a list of platforms, and
> associated MetaData.
{: .callout}

## The simple case: an `ExpressionSet` object

In the simple case, we already have an ExpressionSet object, and we can use the pData from it.  I'm going to use some _functional programming_ ideas to get the CEL file name from  the supplementary file column.


~~~
library(tidyverse)
pd <- pData(gse[[1]])[,c("supplementary_file","culture medium:ch1")]
pd['cel_file'] <- str_split(pd$supplementary_file,"/") %>% map_chr(tail,1)
pd
~~~
{: .language-r}



~~~
                                                                         supplementary_file
GSM820817 ftp://ftp.ncbi.nlm.nih.gov/geo/samples/GSM820nnn/GSM820817/suppl/GSM820817.CEL.gz
GSM820818 ftp://ftp.ncbi.nlm.nih.gov/geo/samples/GSM820nnn/GSM820818/suppl/GSM820818.CEL.gz
GSM820819 ftp://ftp.ncbi.nlm.nih.gov/geo/samples/GSM820nnn/GSM820819/suppl/GSM820819.CEL.gz
GSM820820 ftp://ftp.ncbi.nlm.nih.gov/geo/samples/GSM820nnn/GSM820820/suppl/GSM820820.CEL.gz
GSM820821 ftp://ftp.ncbi.nlm.nih.gov/geo/samples/GSM820nnn/GSM820821/suppl/GSM820821.CEL.gz
GSM820822 ftp://ftp.ncbi.nlm.nih.gov/geo/samples/GSM820nnn/GSM820822/suppl/GSM820822.CEL.gz
          culture medium:ch1         cel_file
GSM820817               MEGM GSM820817.CEL.gz
GSM820818               MEGM GSM820818.CEL.gz
GSM820819               MEGM GSM820819.CEL.gz
GSM820820               SCGM GSM820820.CEL.gz
GSM820821               SCGM GSM820821.CEL.gz
GSM820822               SCGM GSM820822.CEL.gz
~~~
{: .output}

With this simple trick, we now can re-read out CEL files, and _guarantee_ that they are in the correct order as the experimental data we have from getGEO.


~~~
celfile_data <- read.celfiles(paste0('data/',pd$cel_file),phenoData=phenoData(gse[[1]]))
~~~
{: .language-r}



~~~
Reading in : data/GSM820817.CEL.gz
Reading in : data/GSM820818.CEL.gz
Reading in : data/GSM820819.CEL.gz
Reading in : data/GSM820820.CEL.gz
Reading in : data/GSM820821.CEL.gz
Reading in : data/GSM820822.CEL.gz
~~~
{: .output}



~~~
Warning in read.celfiles(paste0("data/", pd$cel_file), phenoData =
phenoData(gse[[1]])): 'channel' automatically added to varMetadata in phenoData.
~~~
{: .error}
We get a warning because some extra information about detection channels is added, but no matter: we have already gotten the treatment conditions attached to our data!


~~~
celfile_data[['culture medium:ch1']]
~~~
{: .language-r}



~~~
[1] "MEGM" "MEGM" "MEGM" "SCGM" "SCGM" "SCGM"
~~~
{: .output}

## The more convoluted case: a `GSE` object

Our GSE object doesn't have an ExpressionSet object in it, so we have to think a bit more about how to get what metadata we need into our eventual pData object. Let's as first what metadata we _have_.


~~~
names(Meta(gse2))
~~~
{: .language-r}



~~~
 [1] "contact_address"         "contact_city"           
 [3] "contact_country"         "contact_department"     
 [5] "contact_institute"       "contact_laboratory"     
 [7] "contact_name"            "contact_state"          
 [9] "contact_zip/postal_code" "contributor"            
[11] "email"                   "geo_accession"          
[13] "institute"               "last_update_date"       
[15] "name"                    "overall_design"         
[17] "platform_id"             "platform_taxid"         
[19] "relation"                "sample_id"              
[21] "sample_taxid"            "status"                 
[23] "submission_date"         "summary"                
[25] "supplementary_file"      "title"                  
[27] "type"                    "web_link"               
~~~
{: .output}
These are all the information we have in the metadata of the _series_. But the sample information is in each GSM object not the GSE itself, so let's look there. Since we have a list of samples in `GSMList`, we can look there. 


~~~
names(Meta(GSMList(gse2)[[1]]))
~~~
{: .language-r}



~~~
 [1] "channel_count"           "characteristics_ch1"    
 [3] "contact_address"         "contact_city"           
 [5] "contact_country"         "contact_department"     
 [7] "contact_institute"       "contact_laboratory"     
 [9] "contact_name"            "contact_state"          
[11] "contact_zip/postal_code" "data_processing"        
[13] "data_row_count"          "description"            
[15] "extract_protocol_ch1"    "geo_accession"          
[17] "growth_protocol_ch1"     "hyb_protocol"           
[19] "label_ch1"               "label_protocol_ch1"     
[21] "last_update_date"        "molecule_ch1"           
[23] "organism_ch1"            "platform_id"            
[25] "scan_protocol"           "series_id"              
[27] "source_name_ch1"         "status"                 
[29] "submission_date"         "supplementary_file"     
[31] "taxid_ch1"               "title"                  
[33] "treatment_protocol_ch1"  "type"                   
~~~
{: .output}

Compare the metadata for the GSE and the GSM. See how much of it is repeated?  We can find out which ones are different using a combination of `!` and `%in%`:

> ## Try it!
>
> See if you can extract the subset of metadata that is *present* in the GSM but *not present in the GSE. These are the metadata that describe each sample, rather than the whole series.
>
> > ## Solution
> >
> > The `names()` function gives us the character vectors we want to compare. We can use `%in%` to
> > give us a logical vector of which GSM metadata is also in GSE metadata. We then use `!` to invert
> > the logic. The result is the metadata of GSM that is *not* in the GSE.
> > We can then extract the values for those names.
> >
> > 
> > ~~~
> > gsm <- GSMList(gse2)[[1]]
> > names(Meta(gsm))[!(names(Meta(gsm)) %in% names(Meta(gse2)))]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> >  [1] "channel_count"          "characteristics_ch1"    "data_processing"       
> >  [4] "data_row_count"         "description"            "extract_protocol_ch1"  
> >  [7] "growth_protocol_ch1"    "hyb_protocol"           "label_ch1"             
> > [10] "label_protocol_ch1"     "molecule_ch1"           "organism_ch1"          
> > [13] "scan_protocol"          "series_id"              "source_name_ch1"       
> > [16] "taxid_ch1"              "treatment_protocol_ch1"
> > ~~~
> > {: .output}
> > 
> > 
> > 
> > ~~~
> > Meta(gsm)[!(names(Meta(gsm)) %in% names(Meta(gse2)))]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > $channel_count
> > [1] "1"
> > 
> > $characteristics_ch1
> > [1] "cell line: Human breast cancer-derived cell line DKAT"
> > [2] "culture medium: MEGM"                                 
> > 
> > $data_processing
> > [1] "The data were analyzed with RMA using the affy package implemented in BRB array tools (Simon and Lam, ver. 3.7.0; R ver. 2.6.0)"
> > 
> > $data_row_count
> > [1] "54675"
> > 
> > $description
> > [1] "DKAT cells cultured in MEGM (Lonza)" "HGU133(+2.0)_04_D1.CEL"             
> > 
> > $extract_protocol_ch1
> > [1] "Extraction of total RNA was performed using the Qiagen RNeasy kit according to the manufacturer's instructions with option DNAse step."
> > 
> > $growth_protocol_ch1
> > [1] "DKAT cells (passage 10) in MEGM were split and grown for 14 days either in MEGM (Lonza) or SCGM (Lonza) in adherent culture."
> > 
> > $hyb_protocol
> > [1] "Following fragmentation, 10 ug of cRNA were hybridized in an Affymetrix Hybridization Oven 640 for 16 hr at 45°C on HG-U133 Plus2.0 GeneChips. GeneChips were washed and stained on an Affymetrix Fluidics Station 450, using the manufacture’s recommended protocol."
> > 
> > $label_ch1
> > [1] "biotin"
> > 
> > $label_protocol_ch1
> > [1] "Biotinylated cRNA were prepared according to the standard Affymetrix protocol from 4ug total RNA (Expression Analysis Technical Manual, 2001, Affymetrix)."
> > 
> > $molecule_ch1
> > [1] "total RNA"
> > 
> > $organism_ch1
> > [1] "Homo sapiens"
> > 
> > $scan_protocol
> > [1] "GeneChips were scanned using an Affymetrix GeneChip Scanner."
> > 
> > $series_id
> > [1] "GSE33146" "GSE33167"
> > 
> > $source_name_ch1
> > [1] "DKAT cells cultured in MEGM (Lonza)"
> > 
> > $taxid_ch1
> > [1] "9606"
> > 
> > $treatment_protocol_ch1
> > [1] "DKAT cells (passage 10) in MEGM were split and grown for 14 days either in MEGM (Lonza) or SCGM (Lonza) in adherent culture."
> > ~~~
> > {: .output}
> > Now we can see that a few metadata elements tell us the key information: 
> > which samples are grown in which media. It looks like we can use 
> > `source_name_ch1`, `growth_protocol_ch1`, or `characteristics_ch1`.
> {: .solution}
{: .challenge}

## Getting the sample growth conditions into a data frame


~~~
for (gsm in GSMList(gse2)) { 
  print(Meta(gsm)[['characteristics_ch1']])
  }
~~~
{: .language-r}



~~~
[1] "cell line: Human breast cancer-derived cell line DKAT"
[2] "culture medium: MEGM"                                 
[1] "cell line: Human breast cancer-derived cell line DKAT"
[2] "culture medium: MEGM"                                 
[1] "cell line: Human breast cancer-derived cell line DKAT"
[2] "culture medium: MEGM"                                 
[1] "cell line: Human breast cancer-derived cell line DKAT"
[2] "culture medium: SCGM"                                 
[1] "cell line: Human breast cancer-derived cell line DKAT"
[2] "culture medium: SCGM"                                 
[1] "cell line: Human breast cancer-derived cell line DKAT"
[2] "culture medium: SCGM"                                 
~~~
{: .output}

OK, that looks right, but *printing* the results are a side effect; it doesn't get us any data. Remember how R `apply` loops work?


~~~
culture_medium <- function(gsm) { 
  Meta(gsm)[['characteristics_ch1']][2]
}
sapply(GSMList(gse2),culture_medium)
~~~
{: .language-r}



~~~
             GSM820817              GSM820818              GSM820819 
"culture medium: MEGM" "culture medium: MEGM" "culture medium: MEGM" 
             GSM820820              GSM820821              GSM820822 
"culture medium: SCGM" "culture medium: SCGM" "culture medium: SCGM" 
~~~
{: .output}

This works a lot like a `for` loop, but returns data from a function. 

Let's put it into a data frame. This will use the names of the samples (the names of `GSMList(gse2)`) as the row.names.


~~~
pd <- data.frame(culture=as.factor(sapply(GSMList(gse2),culture_medium)))
~~~
{: .language-r}


|          |culture              |
|:---------|:--------------------|
|GSM820817 |culture medium: MEGM |
|GSM820818 |culture medium: MEGM |
|GSM820819 |culture medium: MEGM |
|GSM820820 |culture medium: SCGM |
|GSM820821 |culture medium: SCGM |
|GSM820822 |culture medium: SCGM |

The `culture` column only has two values; let's make it a bit simpler.


~~~
pd$culture <- as.factor(pd$culture)
levels(pd$culture) <- c("MEGM","SCGM")
~~~
{: .language-r}


|          |culture |
|:---------|:-------|
|GSM820817 |MEGM    |
|GSM820818 |MEGM    |
|GSM820819 |MEGM    |
|GSM820820 |SCGM    |
|GSM820821 |SCGM    |
|GSM820822 |SCGM    |


## Reading in the CEL files with the phenoData

> ## Solution
>
> 
> ~~~
> celfiles <- paste0('data/',rownames(pd),'.CEL.gz')
> affydata <- read.celfiles(celfiles,phenoData = new("AnnotatedDataFrame",pd))
> ~~~
> {: .language-r}
> 
> 
> 
> ~~~
> Platform design info loaded.
> ~~~
> {: .output}
> 
> 
> 
> ~~~
> Reading in : data/GSM820817.CEL.gz
> Reading in : data/GSM820818.CEL.gz
> Reading in : data/GSM820819.CEL.gz
> Reading in : data/GSM820820.CEL.gz
> Reading in : data/GSM820821.CEL.gz
> Reading in : data/GSM820822.CEL.gz
> ~~~
> {: .output}
> 
> 
> 
> ~~~
> Warning in read.celfiles(celfiles, phenoData = new("AnnotatedDataFrame", :
> 'channel' automatically added to varMetadata in phenoData.
> ~~~
> {: .error}
> 
> 
> 
> ~~~
> pData(affydata)
> ~~~
> {: .language-r}
> 
> 
> 
> ~~~
>           culture
> GSM820817    MEGM
> GSM820818    MEGM
> GSM820819    MEGM
> GSM820820    SCGM
> GSM820821    SCGM
> GSM820822    SCGM
> ~~~
> {: .output}
> That works, and no errors! We are good to go.
>
{: .solution}




{% include site-links.md %} 
{% include links.md %} 
